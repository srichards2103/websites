<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>A* Algorithm Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        h1 {
            background-color: #2c3e50;
            color: #ecf0f1;
            width: 100%;
            text-align: center;
            padding: 20px 0;
            margin: 0;
        }
        #container {
            display: flex;
            flex-direction: row;
            margin: 20px;
        }
        #graph-container {
            position: relative;
            flex: 1;
        }
        #graph {
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 5px;
        }
        #info-panel {
            margin-left: 20px;
            max-width: 400px;
            flex: 0.5;
        }
        #controls {
            margin: 20px;
            text-align: center;
        }
        #controls button {
            margin-right: 10px;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
        }
        #cost-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        #cost-table th, #cost-table td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
        }
        #cost-table th {
            background-color: #2980b9;
            color: #fff;
        }
        #description {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        #pseudocode {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
        }
        #pseudocode pre {
            background-color: #fff;
            padding: 10px;
            border-left: 4px solid #2980b9;
            overflow-x: auto;
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            transition: fill 0.3s;
        }
        .edge {
            transition: stroke 0.3s, stroke-width 0.3s;
        }
    </style>
</head>
<body>

<h1>A* Algorithm Visualization</h1>

<div id="controls">
    <button onclick="startAlgorithm()">Start Algorithm</button>
    <button onclick="stepAlgorithm()">Step Forward</button>
    <button onclick="resetAlgorithm()">Reset</button>
</div>

<div id="container">
    <div id="graph-container">
        <svg id="graph" width="800" height="600"></svg>
    </div>
    <div id="info-panel">
        <table id="cost-table">
            <tr>
                <th>Node</th>
                <th>g(n)</th>
                <th>h(n)</th>
                <th>f(n) = g(n) + h(n)</th>
                <th>Previous Node</th>
            </tr>
        </table>
        <div id="description">
            <h2>Algorithm Steps:</h2>
            <p id="step-description">Click "Start Algorithm" or "Step Forward" to begin.</p>
        </div>
        <div id="pseudocode">
            <h2>Pseudocode:</h2>
            <pre>
Let \( openSet \) be a priority queue of nodes to be evaluated.
Initialize \( g(n) \) to infinity for all nodes, except the start node where \( g(\text{start}) = 0 \).
Initialize \( f(n) = g(n) + h(n) \) for all nodes.
While \( openSet \) is not empty:
    Current node \( n \leftarrow \) node in \( openSet \) with lowest \( f(n) \).
    If \( n \) is the goal node:
        Reconstruct path and return.
    Move \( n \) from \( openSet \) to \( closedSet \).
    For each neighbor \( m \) of \( n \):
        If \( m \) in \( closedSet \):
            Continue.
        Tentative \( g(m) = g(n) + \text{dist}(n, m) \).
        If \( m \) not in \( openSet \) or tentative \( g(m) < g(m) \):
            Set \( \text{previous}(m) = n \).
            Set \( g(m) = \) tentative \( g(m) \).
            Set \( f(m) = g(m) + h(m) \).
            If \( m \) not in \( openSet \):
                Add \( m \) to \( openSet \).
            </pre>
        </div>
    </div>
</div>

<script>
    // Graph data with heuristic values (h(n))
    const nodes = [
        { id: 'A', x: 100, y: 300, h: 7 },
        { id: 'B', x: 200, y: 100, h: 6 },
        { id: 'C', x: 200, y: 500, h: 8 },
        { id: 'D', x: 350, y: 200, h: 5 },
        { id: 'E', x: 350, y: 400, h: 5 },
        { id: 'F', x: 500, y: 100, h: 3 },
        { id: 'G', x: 500, y: 500, h: 3 },
        { id: 'H', x: 650, y: 300, h: 0 }, // Goal node
        { id: 'I', x: 500, y: 300, h: 2 },
        { id: 'J', x: 350, y: 300, h: 4 }
    ];

    const edges = [
        { from: 'A', to: 'B', weight: 4 },
        { from: 'A', to: 'C', weight: 2 },
        { from: 'B', to: 'D', weight: 5 },
        { from: 'C', to: 'E', weight: 3 },
        { from: 'D', to: 'F', weight: 1 },
        { from: 'E', to: 'G', weight: 6 },
        { from: 'F', to: 'H', weight: 2 },
        { from: 'G', to: 'H', weight: 1 },
        { from: 'D', to: 'J', weight: 2 },
        { from: 'E', to: 'J', weight: 4 },
        { from: 'J', to: 'I', weight: 3 },
        { from: 'I', to: 'H', weight: 2 },
        { from: 'F', to: 'I', weight: 7 },
        { from: 'G', to: 'I', weight: 3 }
    ];

    const svg = document.getElementById('graph');
    const stepDescription = document.getElementById('step-description');
    const costTable = document.getElementById('cost-table');

    let openSet = new Set();
    let closedSet = new Set();
    let gScore = {};
    let fScore = {};
    let previous = {};
    let currentNode = null;
    let stepInterval = null;

    // Draw graph
    function drawGraph() {
        // Draw edges
        edges.forEach(edge => {
            const fromNode = nodes.find(n => n.id === edge.from);
            const toNode = nodes.find(n => n.id === edge.to);

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromNode.x);
            line.setAttribute('y1', fromNode.y);
            line.setAttribute('x2', toNode.x);
            line.setAttribute('y2', toNode.y);
            line.setAttribute('stroke', '#999');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('class', 'edge');
            line.setAttribute('id', `edge-${fromNode.id}-${toNode.id}`);
            svg.appendChild(line);

            // Edge weight label
            const midX = (fromNode.x + toNode.x) / 2;
            const midY = (fromNode.y + toNode.y) / 2;
            const weightText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            weightText.setAttribute('x', midX);
            weightText.setAttribute('y', midY - 5);
            weightText.setAttribute('fill', '#555');
            weightText.setAttribute('font-size', '12');
            weightText.setAttribute('text-anchor', 'middle');
            weightText.textContent = edge.weight;
            svg.appendChild(weightText);
        });

        // Draw nodes
        nodes.forEach(node => {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'node');
            group.setAttribute('id', `node-${node.id}`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', node.x);
            circle.setAttribute('cy', node.y);
            circle.setAttribute('r', 20);
            circle.setAttribute('fill', '#fff');
            circle.setAttribute('stroke', '#333');
            circle.setAttribute('stroke-width', '2');
            group.appendChild(circle);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x);
            text.setAttribute('y', node.y + 5);
            text.setAttribute('fill', '#000');
            text.setAttribute('font-size', '16');
            text.setAttribute('text-anchor', 'middle');
            text.textContent = node.id;
            group.appendChild(text);

            // Heuristic value label
            const hText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            hText.setAttribute('x', node.x);
            hText.setAttribute('y', node.y - 25);
            hText.setAttribute('fill', '#555');
            hText.setAttribute('font-size', '12');
            hText.setAttribute('text-anchor', 'middle');
            hText.textContent = `h=${node.h}`;
            group.appendChild(hText);

            svg.appendChild(group);
        });
    }

    // Initialize algorithm
    function initAlgorithm() {
        openSet = new Set();
        closedSet = new Set();
        gScore = {};
        fScore = {};
        previous = {};

        nodes.forEach(node => {
            gScore[node.id] = Infinity;
            fScore[node.id] = Infinity;
            previous[node.id] = null;
        });

        // Set starting node
        const startNode = 'A';
        currentNode = startNode;
        gScore[startNode] = 0;
        fScore[startNode] = gScore[startNode] + nodes.find(n => n.id === startNode).h;
        openSet.add(startNode);

        updateCostTable();
    }

    // Start algorithm
    function startAlgorithm() {
        resetAlgorithm();
        initAlgorithm();
        stepDescription.textContent = 'Starting A* Algorithm from node A.';
        stepInterval = setInterval(runStep, 1000);
    }

    // Step through the algorithm
    function stepAlgorithm() {
        if (!stepInterval) {
            if (openSet.size === 0 && !currentNode) {
                resetAlgorithm();
                initAlgorithm();
            }
            runStep();
        }
    }

    function runStep() {
        if (openSet.size === 0) {
            if (stepInterval) clearInterval(stepInterval);
            stepDescription.textContent = 'No path found.';
            currentNode = null;
            return;
        }

        // Find node in openSet with lowest fScore
        let minF = Infinity;
        openSet.forEach(nodeId => {
            if (fScore[nodeId] < minF) {
                minF = fScore[nodeId];
                currentNode = nodeId;
            }
        });

        // Check if goal node is reached
        if (currentNode === 'H') {
            if (stepInterval) clearInterval(stepInterval);
            stepDescription.textContent = 'Goal reached! Shortest path highlighted in green.';
            highlightShortestPath();
            currentNode = null;
            return;
        }

        openSet.delete(currentNode);
        closedSet.add(currentNode);

        // Update visualization
        highlightNode(currentNode, '#3498db');
        stepDescription.textContent = `Visiting node ${currentNode}.`;

        // Update scores for neighbors
        const neighbors = edges.filter(e => e.from === currentNode || e.to === currentNode);
        neighbors.forEach(edge => {
            const neighborId = edge.from === currentNode ? edge.to : edge.from;

            if (closedSet.has(neighborId)) {
                return;
            }

            const tentativeGScore = gScore[currentNode] + edge.weight;

            if (!openSet.has(neighborId)) {
                openSet.add(neighborId);
            } else if (tentativeGScore >= gScore[neighborId]) {
                return;
            }

            previous[neighborId] = currentNode;
            gScore[neighborId] = tentativeGScore;
            const neighborH = nodes.find(n => n.id === neighborId).h;
            fScore[neighborId] = gScore[neighborId] + neighborH;

            // Visual indication of updated node
            highlightNode(neighborId, '#f1c40f');

            // Highlight edge
            highlightEdge(currentNode, neighborId, '#f1c40f');

            stepDescription.textContent = `Updated scores for node ${neighborId}.`;
        });

        updateCostTable();
    }

    // Highlight node
    function highlightNode(nodeId, color) {
        const nodeGroup = document.getElementById(`node-${nodeId}`);
        const circle = nodeGroup.querySelector('circle');
        circle.setAttribute('fill', color);
    }

    // Highlight edge
    function highlightEdge(nodeId1, nodeId2, color) {
        const edgeId1 = `edge-${nodeId1}-${nodeId2}`;
        const edgeId2 = `edge-${nodeId2}-${nodeId1}`;
        const edge = document.getElementById(edgeId1) || document.getElementById(edgeId2);
        if (edge) {
            edge.setAttribute('stroke', color);
            edge.setAttribute('stroke-width', '4');
        }
    }

    // Highlight shortest path
    function highlightShortestPath() {
        let pathNode = 'H';
        highlightNode(pathNode, '#2ecc71');
        while (previous[pathNode]) {
            const fromNode = pathNode;
            const toNode = previous[pathNode];

            highlightNode(toNode, '#2ecc71');
            highlightEdge(fromNode, toNode, '#2ecc71');

            pathNode = previous[pathNode];
        }
    }

    // Update cost table
    function updateCostTable() {
        // Remove old rows
        const oldRows = costTable.querySelectorAll('tr:not(:first-child)');
        oldRows.forEach(row => row.remove());

        // Add updated rows
        nodes.forEach(node => {
            const row = document.createElement('tr');
            const nodeCell = document.createElement('td');
            nodeCell.textContent = node.id;
            row.appendChild(nodeCell);

            const gCell = document.createElement('td');
            const gValue = gScore[node.id] === Infinity ? '∞' : gScore[node.id];
            gCell.textContent = gValue;
            row.appendChild(gCell);

            const hCell = document.createElement('td');
            hCell.textContent = node.h;
            row.appendChild(hCell);

            const fCell = document.createElement('td');
            const fValue = fScore[node.id] === Infinity ? '∞' : fScore[node.id];
            fCell.textContent = fValue;
            row.appendChild(fCell);

            const prevCell = document.createElement('td');
            prevCell.textContent = previous[node.id] || '-';
            row.appendChild(prevCell);

            costTable.appendChild(row);
        });
    }

    // Reset algorithm and visualization
    function resetAlgorithm() {
        if (stepInterval) clearInterval(stepInterval);
        stepInterval = null;
        svg.innerHTML = '';
        drawGraph();
        stepDescription.textContent = 'Click "Start Algorithm" or "Step Forward" to begin.';
        updateCostTable();
        currentNode = null;
    }

    // Initial draw
    drawGraph();
    updateCostTable();
</script>

</body>
</html>
